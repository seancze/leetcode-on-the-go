prompts:
  - "{{userPrompt}}"

providers:
  - id: file://provider.js
    label: "gpt-5-nano"
    config:
      model: gpt-5-nano
  - id: file://provider.js
    label: "gpt-5.1-codex-mini"
    config:
      model: gpt-5.1-codex-mini

tests:
  - description: "1a - Longest Palindrome Implementation"
    vars:
      userPrompt: |
        Def count_longest(s, left, right):
        While left > -1 and right < len(s) and s[left] == s[right]
        Left -= 1
        Right += 1

        Return max(right-left-1, 0)

        Inside the longestPalindrome function:
        For each i, char in s
        Invoke count_longest(s, i, i) to get longest odd palindrome and set to longest_odd
        Invoke count_longest(s, i, i+1) to get longest even palindrome and set to longest_even

        Set ans to max(ans, longest_odd, longest_even)

        Return ans
      currentCode: |
        class Solution:
            def longestPalindrome(self, s: str) -> str:
      test_code: |
        s="babad"
        sol = Solution()
        print(sol.longestPalindrome(s))
      expected_output: "3"
    assert:
      - type: python
        value: file://assert.py

  - description: "1b - Update to return substring"
    vars:
      userPrompt: |
        update the code so that
        1. ans is renamed to max_length
        2. create a new variable called start which is set to 0
        3. whenever max_length increases in value, set start to i
        4. return s[start:start+max_length]
      currentCode: |
        class Solution:
            def longestPalindrome(self, s: str) -> str:
                def count_longest(s, left, right):
                    while left > -1 and right < len(s) and s[left] == s[right]:
                        left -= 1
                        right += 1
                    return max(right-left-1, 0)

                ans = 0
                for i, char in enumerate(s):
                    longest_odd = count_longest(s, i, i)
                    longest_even = count_longest(s, i, i+1)
                    ans = max(ans, longest_odd, longest_even)
                return ans
      test_code: |
        s="abcabcbb"
        print(Solution().longestPalindrome(s))
      expected_output: '"cbb"'
    assert:
      - type: python
        value: file://assert.py

  - description: "1c - Fix logic for getting start of substring"
    vars:
      userPrompt: |
        1. Rename "count_longest" to "get_longest"
        2. Inside "get_longest", return s[left+1:right]
        3. Remove the start variable altogether
        4. Rename max_length to ans and set it to an empty string initially
        5. Change the if longest_odd and if longest_even logic block to use the len() method
        6. Inside both if logic blocks, set ans = longest_odd or longest_even respectively
      currentCode: |
        class Solution:
            def longestPalindrome(self, s: str) -> str:
                def count_longest(s, left, right):
                    while left > -1 and right < len(s) and s[left] == s[right]:
                        left -= 1
                        right += 1
                    return max(right-left-1, 0)

                max_length = 0
                start = 0
                for i, char in enumerate(s):
                    longest_odd = count_longest(s, i, i)
                    if longest_odd > max_length:
                        max_length = longest_odd
                        start = i

                    longest_even = count_longest(s, i, i+1)
                    if longest_even > max_length:
                        max_length = longest_even
                        start = i

                return s[start:start+max_length]
      test_code: |
        s="abcabcbb"
        print(Solution().longestPalindrome(s))
      expected_output: '"bcb"'
    assert:
      - type: python
        value: file://assert.py

  - description: "2 - Hello World"
    vars:
      userPrompt: 'Please return "Hello, World!"'
      currentCode: |
        class Solution:
            def countNegatives(self, grid: List[List[int]]) -> int:
      test_code: |
        print(Solution().countNegatives([]))
      expected_output: '"Hello, World!"'
    assert:
      - type: python
        value: file://assert.py

  - description: "3 - Long output"
    vars:
      userPrompt: |
        Implement a prefix trie that contains 2 methods
        - insert
        - startsWith

        In the main function code
        - instantiate a prefix trie and set it to my_trie
        - insert all elements of allowed into my_trie

        - let q = [[bottom]]
        - while q
        - let cur = q.popleft()
        - let new_ls = []
        - for i in range(1, len(cur))
        - let possible_char = my_trie.startsWith(cur[i-1:i+1])
        - let temp = []
        - if len(new_ls) == 0
        - for each char in possible_char
        - add [char] to new_ls
        - else
        - for each char in possible_char
        -   for each inner_ls in new_ls
        -     add inner_ls + [char] to temp
        - inner_ls = temp
        - if len(inner_ls[0]) == 1
        -   return true
        - q.extend(inner_ls)

        Return false
      currentCode: |
        class Solution:
            def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:

    assert:
      - type: python
        value: file://assert.py
